begin

### Adapted from liballoc code (https:##github.com/blanham/liballoc)

#include "frame.wach"
#include "kernel.wach"
#include "misc.wach"

#define ALIGNMENT    16
#define ALIGN_TYPE        uint8
#define ALIGN_INFO        sizeof(ALIGN_TYPE)*16

## This macro will conveniently align our pointer upwards
#define ALIGN( ptr )                                                        \
        if (ALIGNMENT > 1) then                                             \
            ALIGN_TYPE *__aligned_p = ptr;                                  \
            __aligned_p += ALIGN_INFO;                                      \
            uint32 diff = __aligned_p & (ALIGNMENT-1);                      \
            if (diff != 0) then                                             \
                diff = ALIGNMENT - diff;                                    \
                __aligned_p += diff;                                        \
            end                                                             \
            *(__aligned_p - ALIGN_INFO) = diff + ALIGN_INFO;                \
            ptr = __aligned_p;                                              \
        end


#define UNALIGN( ptr )                                                      \
        if (ALIGNMENT > 1) then                                             \
            ALIGN_TYPE *__aligned_p = ptr;                                  \
            uint32 diff = *(__aligned_p - ALIGN_INFO);                      \
            if (diff < (ALIGNMENT + ALIGN_INFO)) then                       \
                __aligned_p -= diff;                                        \
            end                                                             \
            ptr = __aligned_p;                                              \
        end

#define LIBALLOC_MAGIC    0xc001c0de
#define LIBALLOC_DEAD     0xdeaddead


## A structure found at the top of all system allocated
## memory blocks. It details the usage of the memory block.
struct liballoc_major is
    struct liballoc_major *prev;
    struct liballoc_major *next;
    uint32 pages;
    uint32 size;
    uint32 usage;
    struct liballoc_minor *first;
end


## This is a structure found at the beginning of all
## sections in a major block which were allocated by a
## malloc, calloc, realloc call.
struct liballoc_minor is
    struct liballoc_minor *prev;
    struct liballoc_minor *next;
    struct liballoc_major *block;
    uint32 magic;
    uint32 size;
    uint32 req_size;
end

struct liballoc_major *l_memRoot = null; ## The root memory block acquired from the system.
struct liballoc_major *l_bestBet = null; ## The major with the most free memory.

uint32 l_pageSize  = 4096; ## The size of an individual page. Set up in liballoc_init.
uint32 l_pageCount = 16;   ## The number of pages to request per chunk. Set up in liballoc_init.
uint32 l_allocated = 0;    ## Running total of allocated memory.
uint32 l_inuse     = 0;    ## Running total of used memory.

struct liballoc_major *allocate_new_page(uint32 size) is
    uint32 st = 0;
    struct liballoc_major *maj = null;

    ## This is how much space is required.
    st = size + sizeof(struct liballoc_major) + sizeof(struct liballoc_minor);

    ## Perfect amount of space?
    if ((st % l_pageSize) == 0) then
        st  = st / (l_pageSize);
    else
        st  = st / (l_pageSize) + 1; ## No, add the buffer.
    end


    ## Make sure it is >= the minimum size.
    if (st < l_pageCount) then st = l_pageCount; end

    maj = mm_alloc_pages(st);

    if (maj == null) then
        panic("Out of memory");
        return null;
    end

    FIXUP_LITERAL_POOL()

    maj.prev   = null;
    maj.next   = null;
    maj.pages  = st;
    maj.size   = st * l_pageSize;
    maj.usage  = sizeof(struct liballoc_major);
    maj.first  = null;

    l_allocated += maj.size;

    return maj;
end

void *kmalloc(uint32 req_size) is
    bool startedBet = false;
    uint32 bestSize = 0;
    void *p = null;
    uint32 diff = 0;
    struct liballoc_major *maj = null;
    struct liballoc_minor *min = null;
    struct liballoc_minor *new_min = null;
    uint32 size = req_size;

    if (ALIGNMENT > 1) then
        size += ALIGNMENT + ALIGN_INFO;
    end

    ##liballoc_lock();

    if (size == 0) then
        panic("trying to allocate 0 bytes");
        return null;
    end


    if (l_memRoot == null) then
        l_memRoot = allocate_new_page(size);

        if (l_memRoot == null) then
            panic("could not allocate a page");
            return null;
        end
    end

    FIXUP_LITERAL_POOL()

    maj = l_memRoot;
    startedBet = false;

    ## Start at the best bet....
    if (l_bestBet != null) then
        bestSize = l_bestBet.size - l_bestBet.usage;

        if (bestSize > (size + sizeof(struct liballoc_minor))) then
            maj = l_bestBet;
            startedBet = true;
        end
    end

    while (maj != null) do
        diff  = maj.size - maj.usage; ## free memory in the block

        if (bestSize < diff) then
            l_bestBet = maj;
            bestSize = diff;
        end

        ## CASE 1:  There is not enough space in this major block.
        if (diff < (size + sizeof(struct liballoc_minor))) then
            ## Another major block next to this one?
            if (maj.next != null) then
                maj = maj.next;        ## Hop to that one.
                continue;
            end

            ## If we started at the best bet, lets start all over again.
            if (startedBet) then
                maj = l_memRoot;
                startedBet = false;
                continue;
            end

            ## Create a new major block next to this one and...
            maj.next = allocate_new_page(size);     ## next one will be okay.
            if (maj.next == null) then break; end   ## no more memory.
            maj.next.prev = maj;
            maj = maj.next;

            ## .. fall through to CASE 2 ..
        end

        ## CASE 2: It is a brand new block.
        if (maj.first == null) then
            uint32 tmp = maj;
            maj.first = tmp + sizeof(struct liballoc_major);

            maj.first.magic     = LIBALLOC_MAGIC;
            maj.first.prev      = null;
            maj.first.next      = null;
            maj.first.block     = maj;
            maj.first.size      = size;
            maj.first.req_size  = req_size;
            maj.usage          += size + sizeof(struct liballoc_minor);

            l_inuse += size;

            tmp = maj.first;
            p = tmp + sizeof(struct liballoc_minor);

            ALIGN(p)

            ##liballoc_unlock();        ## release the lock
            return p;
        end

        ## CASE 3: Block in use and enough space at the start of the block.
        diff  = maj.first;
        diff -= maj;
        diff -= sizeof(struct liballoc_major);

        if (diff >= (size + sizeof(struct liballoc_minor))) then
            ## Yes, space in front. Squeeze in.
            uint32 tmp = maj;
            maj.first.prev = tmp + sizeof(struct liballoc_major);
            maj.first.prev.next = maj.first;
            maj.first = maj.first.prev;

            maj.first.magic     = LIBALLOC_MAGIC;
            maj.first.prev      = null;
            maj.first.block     = maj;
            maj.first.size      = size;
            maj.first.req_size  = req_size;
            maj.usage          += size + sizeof(struct liballoc_minor);

            l_inuse += size;

            tmp = maj.first;
            p = tmp + sizeof(struct liballoc_minor);
            ALIGN(p)

            ##liballoc_unlock();        ## release the lock
            return p;
        end

        FIXUP_LITERAL_POOL()

        ## CASE 4: There is enough space in this block. But is it contiguous?
        min = maj.first;

        ## Looping within the block now...
        while (min != null) do
            ## CASE 4.1: End of minors in a block. Space from last and end?
            if (min.next == null) then
                ## the rest of this block is free...  is it big enough?
                diff  = maj;
                diff += maj.size;
                diff -= min;
                diff -= sizeof(struct liballoc_minor);
                diff -= min.size;
                ## minus already existing usage..

                if (diff >= (size + sizeof(struct liballoc_minor))) then
                    ## yay....
                    uint32 tmp = min;
                    min.next        = tmp + sizeof(struct liballoc_minor) + min.size;
                    min.next.prev   = min;
                    min             = min.next;
                    min.next        = null;
                    min.magic       = LIBALLOC_MAGIC;
                    min.block       = maj;
                    min.size        = size;
                    min.req_size    = req_size;
                    maj.usage      += size + sizeof(struct liballoc_minor);

                    l_inuse += size;

                    p = tmp + sizeof(struct liballoc_minor);
                    ALIGN(p)

                    ##liballoc_unlock();        ## release the lock
                    return p;
                end

            ## CASE 4.2: Is there space between two minors?
            else
                ## is the difference between here and next big enough?
                diff  = min.next;
                diff -= min;
                diff -= sizeof(struct liballoc_minor);
                diff -= min.size; ## minus our existing usage.

                if (diff >= (size + sizeof(struct liballoc_minor))) then
                    ## yay......
                    uint32 tmp = min;
                    new_min = (tmp + sizeof(struct liballoc_minor) + min.size);

                    new_min.magic       = LIBALLOC_MAGIC;
                    new_min.next        = min.next;
                    new_min.prev        = min;
                    new_min.size        = size;
                    new_min.req_size    = req_size;
                    new_min.block       = maj;
                    min.next.prev       = new_min;
                    min.next            = new_min;
                    maj.usage          += size + sizeof(struct liballoc_minor);

                    l_inuse += size;

                    tmp = new_min;
                    p = (tmp + sizeof(struct liballoc_minor));
                    ALIGN(p)


                    ##liballoc_unlock();        ## release the lock
                    return p;
                end
            end  ## min.next != null

            min = min.next;
        end ## while min != null ...


        ## CASE 5: Block full! Ensure next block and loop.
        if (maj.next == null) then
            if (startedBet) then
                maj = l_memRoot;
                startedBet = false;
                continue;
            end

            ## we have run out. we need more...
            maj.next = allocate_new_page(size);
            if (maj.next == null) then break; end
            maj.next.prev = maj;
        end

        maj = maj.next;
    end ## while (maj != null)

    ##liballoc_unlock();        ## release the lock

    panic("Out of memory");
    return null;
end

void kfree(void *ptr) is
    struct liballoc_minor *min = null;
    struct liballoc_major *maj = null;

    if (ptr == null) then
        panic("Attempt to free null pointer");
        return;
    end

    UNALIGN(ptr)

    ##liballoc_lock();        ## lockit

    min = ptr - sizeof(struct liballoc_minor);

    if (min.magic != LIBALLOC_MAGIC) then
        panic("invalid kfree");
    end

    maj = min.block;

    l_inuse -= min.size;

    maj.usage -= min.size + sizeof(struct liballoc_minor);
    min.magic  = LIBALLOC_DEAD;        ## No mojo.

    if (min.next != null) then min.next.prev = min.prev; end
    if (min.prev != null) then min.prev.next = min.next; end

    ## Might empty the block. This was the first minor.
    if (min.prev == null) then maj.first = min.next; end

    ## Block completely unused.
    if (maj.first == null) then
        if (l_memRoot == maj) then l_memRoot = maj.next; end
        if (l_bestBet == maj) then l_bestBet = null; end
        if (maj.prev != null) then maj.prev.next = maj.next; end
        if (maj.next != null) then maj.next.prev = maj.prev; end
        l_allocated -= maj.size;

        mm_free_pages(maj, maj.pages);
    else
        if (l_bestBet != null) then
            int bestSize = l_bestBet.size  - l_bestBet.usage;
            int majSize = maj.size - maj.usage;

            if (majSize > bestSize) then l_bestBet = maj; end
        end
    end

    ##liballoc_unlock();        ## release the lock
end

end
